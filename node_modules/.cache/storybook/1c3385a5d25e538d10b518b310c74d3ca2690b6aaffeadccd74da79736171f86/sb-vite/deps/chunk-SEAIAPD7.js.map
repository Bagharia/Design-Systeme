{
  "version": 3,
  "sources": ["../../../../../jsdoc-type-pratt-parser/dist/index.js"],
  "sourcesContent": ["(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\r\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\r\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jtpp = {}));\r\n})(this, (function (exports) { 'use strict';\r\n\r\n    function tokenToString(token) {\r\n        if (token.text !== undefined && token.text !== '') {\r\n            return `'${token.type}' with value '${token.text}'`;\r\n        }\r\n        else {\r\n            return `'${token.type}'`;\r\n        }\r\n    }\r\n    class NoParsletFoundError extends Error {\r\n        constructor(token) {\r\n            super(`No parslet found for token: ${tokenToString(token)}`);\r\n            this.token = token;\r\n            Object.setPrototypeOf(this, NoParsletFoundError.prototype);\r\n        }\r\n        getToken() {\r\n            return this.token;\r\n        }\r\n    }\r\n    class EarlyEndOfParseError extends Error {\r\n        constructor(token) {\r\n            super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\r\n            this.token = token;\r\n            Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\r\n        }\r\n        getToken() {\r\n            return this.token;\r\n        }\r\n    }\r\n    class UnexpectedTypeError extends Error {\r\n        constructor(result, message) {\r\n            let error = `Unexpected type: '${result.type}'.`;\r\n            if (message !== undefined) {\r\n                error += ` Message: ${message}`;\r\n            }\r\n            super(error);\r\n            Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\r\n        }\r\n    }\r\n    // export class UnexpectedTokenError extends Error {\r\n    //   private expected: Token\r\n    //   private found: Token\r\n    //\r\n    //   constructor (expected: Token, found: Token) {\r\n    //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\r\n    //\r\n    //     this.token = token\r\n    //\r\n    //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\r\n    //   }\r\n    //\r\n    //   getToken() {\r\n    //     return this.token\r\n    //   }\r\n    // }\r\n\r\n    function makePunctuationRule(type) {\r\n        return text => {\r\n            if (text.startsWith(type)) {\r\n                return { type, text: type };\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        };\r\n    }\r\n    function getQuoted(text) {\r\n        let position = 0;\r\n        let char;\r\n        const mark = text[0];\r\n        let escaped = false;\r\n        if (mark !== '\\'' && mark !== '\"') {\r\n            return null;\r\n        }\r\n        while (position < text.length) {\r\n            position++;\r\n            char = text[position];\r\n            if (!escaped && char === mark) {\r\n                position++;\r\n                break;\r\n            }\r\n            escaped = !escaped && char === '\\\\';\r\n        }\r\n        if (char !== mark) {\r\n            throw new Error('Unterminated String');\r\n        }\r\n        return text.slice(0, position);\r\n    }\r\n    const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\r\n    // A hyphen is not technically allowed, but to keep it liberal for now,\r\n    //  adding it here\r\n    const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\r\n    function getIdentifier(text) {\r\n        let char = text[0];\r\n        if (!identifierStartRegex.test(char)) {\r\n            return null;\r\n        }\r\n        let position = 1;\r\n        do {\r\n            char = text[position];\r\n            if (!identifierContinueRegex.test(char)) {\r\n                break;\r\n            }\r\n            position++;\r\n        } while (position < text.length);\r\n        return text.slice(0, position);\r\n    }\r\n    // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\r\n    const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\r\n    function getNumber(text) {\r\n        var _a, _b;\r\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\r\n    }\r\n    const identifierRule = text => {\r\n        const value = getIdentifier(text);\r\n        if (value == null) {\r\n            return null;\r\n        }\r\n        return {\r\n            type: 'Identifier',\r\n            text: value\r\n        };\r\n    };\r\n    function makeKeyWordRule(type) {\r\n        return text => {\r\n            if (!text.startsWith(type)) {\r\n                return null;\r\n            }\r\n            const prepends = text[type.length];\r\n            if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\r\n                return null;\r\n            }\r\n            return {\r\n                type,\r\n                text: type\r\n            };\r\n        };\r\n    }\r\n    const stringValueRule = text => {\r\n        const value = getQuoted(text);\r\n        if (value == null) {\r\n            return null;\r\n        }\r\n        return {\r\n            type: 'StringValue',\r\n            text: value\r\n        };\r\n    };\r\n    const eofRule = text => {\r\n        if (text.length > 0) {\r\n            return null;\r\n        }\r\n        return {\r\n            type: 'EOF',\r\n            text: ''\r\n        };\r\n    };\r\n    const numberRule = text => {\r\n        const value = getNumber(text);\r\n        if (value === null) {\r\n            return null;\r\n        }\r\n        return {\r\n            type: 'Number',\r\n            text: value\r\n        };\r\n    };\r\n    const rules = [\r\n        eofRule,\r\n        makePunctuationRule('=>'),\r\n        makePunctuationRule('('),\r\n        makePunctuationRule(')'),\r\n        makePunctuationRule('{'),\r\n        makePunctuationRule('}'),\r\n        makePunctuationRule('['),\r\n        makePunctuationRule(']'),\r\n        makePunctuationRule('|'),\r\n        makePunctuationRule('&'),\r\n        makePunctuationRule('<'),\r\n        makePunctuationRule('>'),\r\n        makePunctuationRule(','),\r\n        makePunctuationRule(';'),\r\n        makePunctuationRule('*'),\r\n        makePunctuationRule('?'),\r\n        makePunctuationRule('!'),\r\n        makePunctuationRule('='),\r\n        makePunctuationRule(':'),\r\n        makePunctuationRule('...'),\r\n        makePunctuationRule('.'),\r\n        makePunctuationRule('#'),\r\n        makePunctuationRule('~'),\r\n        makePunctuationRule('/'),\r\n        makePunctuationRule('@'),\r\n        makeKeyWordRule('undefined'),\r\n        makeKeyWordRule('null'),\r\n        makeKeyWordRule('function'),\r\n        makeKeyWordRule('this'),\r\n        makeKeyWordRule('new'),\r\n        makeKeyWordRule('module'),\r\n        makeKeyWordRule('event'),\r\n        makeKeyWordRule('external'),\r\n        makeKeyWordRule('typeof'),\r\n        makeKeyWordRule('keyof'),\r\n        makeKeyWordRule('readonly'),\r\n        makeKeyWordRule('import'),\r\n        makeKeyWordRule('is'),\r\n        makeKeyWordRule('in'),\r\n        makeKeyWordRule('asserts'),\r\n        numberRule,\r\n        identifierRule,\r\n        stringValueRule\r\n    ];\r\n    const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\r\n    class Lexer {\r\n        static create(text) {\r\n            const current = this.read(text);\r\n            text = current.text;\r\n            const next = this.read(text);\r\n            text = next.text;\r\n            return new Lexer(text, undefined, current.token, next.token);\r\n        }\r\n        constructor(text, previous, current, next) {\r\n            this.text = '';\r\n            this.text = text;\r\n            this.previous = previous;\r\n            this.current = current;\r\n            this.next = next;\r\n        }\r\n        static read(text, startOfLine = false) {\r\n            startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\r\n            text = text.trim();\r\n            for (const rule of rules) {\r\n                const partial = rule(text);\r\n                if (partial !== null) {\r\n                    const token = Object.assign(Object.assign({}, partial), { startOfLine });\r\n                    text = text.slice(token.text.length);\r\n                    return { text, token };\r\n                }\r\n            }\r\n            throw new Error('Unexpected Token ' + text);\r\n        }\r\n        advance() {\r\n            const next = Lexer.read(this.text);\r\n            return new Lexer(next.text, this.current, this.next, next.token);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Throws an error if the provided result is not a {@link RootResult}\r\n     */\r\n    function assertRootResult(result) {\r\n        if (result === undefined) {\r\n            throw new Error('Unexpected undefined');\r\n        }\r\n        if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||\r\n            result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||\r\n            result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||\r\n            result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType') {\r\n            throw new UnexpectedTypeError(result);\r\n        }\r\n        return result;\r\n    }\r\n    function assertPlainKeyValueOrRootResult(result) {\r\n        if (result.type === 'JsdocTypeKeyValue') {\r\n            return assertPlainKeyValueResult(result);\r\n        }\r\n        return assertRootResult(result);\r\n    }\r\n    function assertPlainKeyValueOrNameResult(result) {\r\n        if (result.type === 'JsdocTypeName') {\r\n            return result;\r\n        }\r\n        return assertPlainKeyValueResult(result);\r\n    }\r\n    function assertPlainKeyValueResult(result) {\r\n        if (result.type !== 'JsdocTypeKeyValue') {\r\n            throw new UnexpectedTypeError(result);\r\n        }\r\n        return result;\r\n    }\r\n    function assertNumberOrVariadicNameResult(result) {\r\n        var _a;\r\n        if (result.type === 'JsdocTypeVariadic') {\r\n            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\r\n                return result;\r\n            }\r\n            throw new UnexpectedTypeError(result);\r\n        }\r\n        if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\r\n            throw new UnexpectedTypeError(result);\r\n        }\r\n        return result;\r\n    }\r\n    function isSquaredProperty(result) {\r\n        return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\r\n    }\r\n\r\n    // higher precedence = higher importance\r\n    var Precedence;\r\n    (function (Precedence) {\r\n        Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\r\n        Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\r\n        Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\r\n        Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\r\n        Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\r\n        Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\r\n        Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\r\n        Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\r\n        Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\r\n        Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\r\n        Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\r\n        Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\r\n        Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\r\n        Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\r\n        Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\r\n        Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\r\n        Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\r\n        Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\r\n        Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\r\n        Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\r\n        Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\r\n    })(Precedence || (Precedence = {}));\r\n\r\n    class Parser {\r\n        constructor(grammar, textOrLexer, baseParser) {\r\n            this.grammar = grammar;\r\n            if (typeof textOrLexer === 'string') {\r\n                this._lexer = Lexer.create(textOrLexer);\r\n            }\r\n            else {\r\n                this._lexer = textOrLexer;\r\n            }\r\n            this.baseParser = baseParser;\r\n        }\r\n        get lexer() {\r\n            return this._lexer;\r\n        }\r\n        /**\r\n         * Parses a given string and throws an error if the parse ended before the end of the string.\r\n         */\r\n        parse() {\r\n            const result = this.parseType(Precedence.ALL);\r\n            if (this.lexer.current.type !== 'EOF') {\r\n                throw new EarlyEndOfParseError(this.lexer.current);\r\n            }\r\n            return result;\r\n        }\r\n        /**\r\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\r\n         */\r\n        parseType(precedence) {\r\n            return assertRootResult(this.parseIntermediateType(precedence));\r\n        }\r\n        /**\r\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\r\n         * to parse the state in the infix step.\r\n         */\r\n        parseIntermediateType(precedence) {\r\n            const result = this.tryParslets(null, precedence);\r\n            if (result === null) {\r\n                throw new NoParsletFoundError(this.lexer.current);\r\n            }\r\n            return this.parseInfixIntermediateType(result, precedence);\r\n        }\r\n        /**\r\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\r\n         * a result.\r\n         */\r\n        parseInfixIntermediateType(left, precedence) {\r\n            let result = this.tryParslets(left, precedence);\r\n            while (result !== null) {\r\n                left = result;\r\n                result = this.tryParslets(left, precedence);\r\n            }\r\n            return left;\r\n        }\r\n        /**\r\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\r\n         */\r\n        tryParslets(left, precedence) {\r\n            for (const parslet of this.grammar) {\r\n                const result = parslet(this, precedence, left);\r\n                if (result !== null) {\r\n                    return result;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        /**\r\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\r\n         * advanced.\r\n         */\r\n        consume(types) {\r\n            if (!Array.isArray(types)) {\r\n                types = [types];\r\n            }\r\n            if (types.includes(this.lexer.current.type)) {\r\n                this._lexer = this.lexer.advance();\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        acceptLexerState(parser) {\r\n            this._lexer = parser.lexer;\r\n        }\r\n    }\r\n\r\n    function isQuestionMarkUnknownType(next) {\r\n        return next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\r\n    }\r\n\r\n    const nullableParslet = (parser, precedence, left) => {\r\n        const type = parser.lexer.current.type;\r\n        const next = parser.lexer.next.type;\r\n        const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||\r\n            ((left != null) && type === '?');\r\n        if (!accept) {\r\n            return null;\r\n        }\r\n        parser.consume('?');\r\n        if (left == null) {\r\n            return {\r\n                type: 'JsdocTypeNullable',\r\n                element: parser.parseType(Precedence.NULLABLE),\r\n                meta: {\r\n                    position: 'prefix'\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                type: 'JsdocTypeNullable',\r\n                element: assertRootResult(left),\r\n                meta: {\r\n                    position: 'suffix'\r\n                }\r\n            };\r\n        }\r\n    };\r\n\r\n    function composeParslet(options) {\r\n        const parslet = (parser, curPrecedence, left) => {\r\n            const type = parser.lexer.current.type;\r\n            const next = parser.lexer.next.type;\r\n            if (left === null) {\r\n                if ('parsePrefix' in options) {\r\n                    if (options.accept(type, next)) {\r\n                        return options.parsePrefix(parser);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if ('parseInfix' in options) {\r\n                    if (options.precedence > curPrecedence && options.accept(type, next)) {\r\n                        return options.parseInfix(parser, left);\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        // for debugging\r\n        Object.defineProperty(parslet, 'name', {\r\n            value: options.name\r\n        });\r\n        return parslet;\r\n    }\r\n\r\n    const optionalParslet = composeParslet({\r\n        name: 'optionalParslet',\r\n        accept: type => type === '=',\r\n        precedence: Precedence.OPTIONAL,\r\n        parsePrefix: parser => {\r\n            parser.consume('=');\r\n            return {\r\n                type: 'JsdocTypeOptional',\r\n                element: parser.parseType(Precedence.OPTIONAL),\r\n                meta: {\r\n                    position: 'prefix'\r\n                }\r\n            };\r\n        },\r\n        parseInfix: (parser, left) => {\r\n            parser.consume('=');\r\n            return {\r\n                type: 'JsdocTypeOptional',\r\n                element: assertRootResult(left),\r\n                meta: {\r\n                    position: 'suffix'\r\n                }\r\n            };\r\n        }\r\n    });\r\n\r\n    const numberParslet = composeParslet({\r\n        name: 'numberParslet',\r\n        accept: type => type === 'Number',\r\n        parsePrefix: parser => {\r\n            const value = parseFloat(parser.lexer.current.text);\r\n            parser.consume('Number');\r\n            return {\r\n                type: 'JsdocTypeNumber',\r\n                value\r\n            };\r\n        }\r\n    });\r\n\r\n    const parenthesisParslet = composeParslet({\r\n        name: 'parenthesisParslet',\r\n        accept: type => type === '(',\r\n        parsePrefix: parser => {\r\n            parser.consume('(');\r\n            if (parser.consume(')')) {\r\n                return {\r\n                    type: 'JsdocTypeParameterList',\r\n                    elements: []\r\n                };\r\n            }\r\n            const result = parser.parseIntermediateType(Precedence.ALL);\r\n            if (!parser.consume(')')) {\r\n                throw new Error('Unterminated parenthesis');\r\n            }\r\n            if (result.type === 'JsdocTypeParameterList') {\r\n                return result;\r\n            }\r\n            else if (result.type === 'JsdocTypeKeyValue') {\r\n                return {\r\n                    type: 'JsdocTypeParameterList',\r\n                    elements: [result]\r\n                };\r\n            }\r\n            return {\r\n                type: 'JsdocTypeParenthesis',\r\n                element: assertRootResult(result)\r\n            };\r\n        }\r\n    });\r\n\r\n    const specialTypesParslet = composeParslet({\r\n        name: 'specialTypesParslet',\r\n        accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||\r\n            type === 'null' || type === 'undefined' || type === '*',\r\n        parsePrefix: parser => {\r\n            if (parser.consume('null')) {\r\n                return {\r\n                    type: 'JsdocTypeNull'\r\n                };\r\n            }\r\n            if (parser.consume('undefined')) {\r\n                return {\r\n                    type: 'JsdocTypeUndefined'\r\n                };\r\n            }\r\n            if (parser.consume('*')) {\r\n                return {\r\n                    type: 'JsdocTypeAny'\r\n                };\r\n            }\r\n            if (parser.consume('?')) {\r\n                return {\r\n                    type: 'JsdocTypeUnknown'\r\n                };\r\n            }\r\n            throw new Error('Unacceptable token: ' + parser.lexer.current.text);\r\n        }\r\n    });\r\n\r\n    const notNullableParslet = composeParslet({\r\n        name: 'notNullableParslet',\r\n        accept: type => type === '!',\r\n        precedence: Precedence.NULLABLE,\r\n        parsePrefix: parser => {\r\n            parser.consume('!');\r\n            return {\r\n                type: 'JsdocTypeNotNullable',\r\n                element: parser.parseType(Precedence.NULLABLE),\r\n                meta: {\r\n                    position: 'prefix'\r\n                }\r\n            };\r\n        },\r\n        parseInfix: (parser, left) => {\r\n            parser.consume('!');\r\n            return {\r\n                type: 'JsdocTypeNotNullable',\r\n                element: assertRootResult(left),\r\n                meta: {\r\n                    position: 'suffix'\r\n                }\r\n            };\r\n        }\r\n    });\r\n\r\n    function createParameterListParslet({ allowTrailingComma }) {\r\n        return composeParslet({\r\n            name: 'parameterListParslet',\r\n            accept: type => type === ',',\r\n            precedence: Precedence.PARAMETER_LIST,\r\n            parseInfix: (parser, left) => {\r\n                const elements = [\r\n                    assertPlainKeyValueOrRootResult(left)\r\n                ];\r\n                parser.consume(',');\r\n                do {\r\n                    try {\r\n                        const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\r\n                        elements.push(assertPlainKeyValueOrRootResult(next));\r\n                    }\r\n                    catch (e) {\r\n                        if (allowTrailingComma && e instanceof NoParsletFoundError) {\r\n                            break;\r\n                        }\r\n                        else {\r\n                            throw e;\r\n                        }\r\n                    }\r\n                } while (parser.consume(','));\r\n                if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\r\n                    throw new Error('Only the last parameter may be a rest parameter');\r\n                }\r\n                return {\r\n                    type: 'JsdocTypeParameterList',\r\n                    elements\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    const genericParslet = composeParslet({\r\n        name: 'genericParslet',\r\n        accept: (type, next) => type === '<' || (type === '.' && next === '<'),\r\n        precedence: Precedence.GENERIC,\r\n        parseInfix: (parser, left) => {\r\n            const dot = parser.consume('.');\r\n            parser.consume('<');\r\n            const objects = [];\r\n            do {\r\n                objects.push(parser.parseType(Precedence.PARAMETER_LIST));\r\n            } while (parser.consume(','));\r\n            if (!parser.consume('>')) {\r\n                throw new Error('Unterminated generic parameter list');\r\n            }\r\n            return {\r\n                type: 'JsdocTypeGeneric',\r\n                left: assertRootResult(left),\r\n                elements: objects,\r\n                meta: {\r\n                    brackets: 'angle',\r\n                    dot\r\n                }\r\n            };\r\n        }\r\n    });\r\n\r\n    const unionParslet = composeParslet({\r\n        name: 'unionParslet',\r\n        accept: type => type === '|',\r\n        precedence: Precedence.UNION,\r\n        parseInfix: (parser, left) => {\r\n            parser.consume('|');\r\n            const elements = [];\r\n            do {\r\n                elements.push(parser.parseType(Precedence.UNION));\r\n            } while (parser.consume('|'));\r\n            return {\r\n                type: 'JsdocTypeUnion',\r\n                elements: [assertRootResult(left), ...elements]\r\n            };\r\n        }\r\n    });\r\n\r\n    const baseGrammar = [\r\n        nullableParslet,\r\n        optionalParslet,\r\n        numberParslet,\r\n        parenthesisParslet,\r\n        specialTypesParslet,\r\n        notNullableParslet,\r\n        createParameterListParslet({\r\n            allowTrailingComma: true\r\n        }),\r\n        genericParslet,\r\n        unionParslet,\r\n        optionalParslet\r\n    ];\r\n\r\n    function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }) {\r\n        return function namePathParslet(parser, precedence, left) {\r\n            if ((left == null) || precedence >= Precedence.NAME_PATH) {\r\n                return null;\r\n            }\r\n            const type = parser.lexer.current.type;\r\n            const next = parser.lexer.next.type;\r\n            const accept = (type === '.' && next !== '<') ||\r\n                (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||\r\n                (allowJsdocNamePaths && (type === '~' || type === '#'));\r\n            if (!accept) {\r\n                return null;\r\n            }\r\n            let pathType;\r\n            let brackets = false;\r\n            if (parser.consume('.')) {\r\n                pathType = 'property';\r\n            }\r\n            else if (parser.consume('[')) {\r\n                pathType = 'property-brackets';\r\n                brackets = true;\r\n            }\r\n            else if (parser.consume('~')) {\r\n                pathType = 'inner';\r\n            }\r\n            else {\r\n                parser.consume('#');\r\n                pathType = 'instance';\r\n            }\r\n            const pathParser = pathGrammar !== null\r\n                ? new Parser(pathGrammar, parser.lexer, parser)\r\n                : parser;\r\n            const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\r\n            parser.acceptLexerState(pathParser);\r\n            let right;\r\n            switch (parsed.type) {\r\n                case 'JsdocTypeName':\r\n                    right = {\r\n                        type: 'JsdocTypeProperty',\r\n                        value: parsed.value,\r\n                        meta: {\r\n                            quote: undefined\r\n                        }\r\n                    };\r\n                    break;\r\n                case 'JsdocTypeNumber':\r\n                    right = {\r\n                        type: 'JsdocTypeProperty',\r\n                        value: parsed.value.toString(10),\r\n                        meta: {\r\n                            quote: undefined\r\n                        }\r\n                    };\r\n                    break;\r\n                case 'JsdocTypeStringValue':\r\n                    right = {\r\n                        type: 'JsdocTypeProperty',\r\n                        value: parsed.value,\r\n                        meta: {\r\n                            quote: parsed.meta.quote\r\n                        }\r\n                    };\r\n                    break;\r\n                case 'JsdocTypeSpecialNamePath':\r\n                    if (parsed.specialType === 'event') {\r\n                        right = parsed;\r\n                    }\r\n                    else {\r\n                        throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\r\n            }\r\n            if (brackets && !parser.consume(']')) {\r\n                const token = parser.lexer.current;\r\n                throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +\r\n                    `with text '${token.text}'`);\r\n            }\r\n            return {\r\n                type: 'JsdocTypeNamePath',\r\n                left: assertRootResult(left),\r\n                right,\r\n                pathType\r\n            };\r\n        };\r\n    }\r\n\r\n    function createNameParslet({ allowedAdditionalTokens }) {\r\n        return composeParslet({\r\n            name: 'nameParslet',\r\n            accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\r\n            parsePrefix: parser => {\r\n                const { type, text } = parser.lexer.current;\r\n                parser.consume(type);\r\n                return {\r\n                    type: 'JsdocTypeName',\r\n                    value: text\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    const stringValueParslet = composeParslet({\r\n        name: 'stringValueParslet',\r\n        accept: type => type === 'StringValue',\r\n        parsePrefix: parser => {\r\n            const text = parser.lexer.current.text;\r\n            parser.consume('StringValue');\r\n            return {\r\n                type: 'JsdocTypeStringValue',\r\n                value: text.slice(1, -1),\r\n                meta: {\r\n                    quote: text[0] === '\\'' ? 'single' : 'double'\r\n                }\r\n            };\r\n        }\r\n    });\r\n\r\n    function createSpecialNamePathParslet({ pathGrammar, allowedTypes }) {\r\n        return composeParslet({\r\n            name: 'specialNamePathParslet',\r\n            accept: type => allowedTypes.includes(type),\r\n            parsePrefix: parser => {\r\n                const type = parser.lexer.current.type;\r\n                parser.consume(type);\r\n                if (!parser.consume(':')) {\r\n                    return {\r\n                        type: 'JsdocTypeName',\r\n                        value: type\r\n                    };\r\n                }\r\n                let result;\r\n                let token = parser.lexer.current;\r\n                if (parser.consume('StringValue')) {\r\n                    result = {\r\n                        type: 'JsdocTypeSpecialNamePath',\r\n                        value: token.text.slice(1, -1),\r\n                        specialType: type,\r\n                        meta: {\r\n                            quote: token.text[0] === '\\'' ? 'single' : 'double'\r\n                        }\r\n                    };\r\n                }\r\n                else {\r\n                    let value = '';\r\n                    const allowed = ['Identifier', '@', '/'];\r\n                    while (allowed.some(type => parser.consume(type))) {\r\n                        value += token.text;\r\n                        token = parser.lexer.current;\r\n                    }\r\n                    result = {\r\n                        type: 'JsdocTypeSpecialNamePath',\r\n                        value,\r\n                        specialType: type,\r\n                        meta: {\r\n                            quote: undefined\r\n                        }\r\n                    };\r\n                }\r\n                const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\r\n                const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\r\n                parser.acceptLexerState(moduleParser);\r\n                return assertRootResult(moduleResult);\r\n            }\r\n        });\r\n    }\r\n\r\n    const basePathGrammar = [\r\n        createNameParslet({\r\n            allowedAdditionalTokens: ['external', 'module']\r\n        }),\r\n        stringValueParslet,\r\n        numberParslet,\r\n        createNamePathParslet({\r\n            allowSquareBracketsOnAnyType: false,\r\n            allowJsdocNamePaths: true,\r\n            pathGrammar: null\r\n        })\r\n    ];\r\n    const pathGrammar = [\r\n        ...basePathGrammar,\r\n        createSpecialNamePathParslet({\r\n            allowedTypes: ['event'],\r\n            pathGrammar: basePathGrammar\r\n        })\r\n    ];\r\n\r\n    function getParameters(value) {\r\n        let parameters;\r\n        if (value.type === 'JsdocTypeParameterList') {\r\n            parameters = value.elements;\r\n        }\r\n        else if (value.type === 'JsdocTypeParenthesis') {\r\n            parameters = [value.element];\r\n        }\r\n        else {\r\n            throw new UnexpectedTypeError(value);\r\n        }\r\n        return parameters.map(p => assertPlainKeyValueOrRootResult(p));\r\n    }\r\n    function getUnnamedParameters(value) {\r\n        const parameters = getParameters(value);\r\n        if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\r\n            throw new Error('No parameter should be named');\r\n        }\r\n        return parameters;\r\n    }\r\n    function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\r\n        return composeParslet({\r\n            name: 'functionParslet',\r\n            accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),\r\n            parsePrefix: parser => {\r\n                const newKeyword = parser.consume('new');\r\n                parser.consume('function');\r\n                const hasParenthesis = parser.lexer.current.type === '(';\r\n                if (!hasParenthesis) {\r\n                    if (!allowWithoutParenthesis) {\r\n                        throw new Error('function is missing parameter list');\r\n                    }\r\n                    return {\r\n                        type: 'JsdocTypeName',\r\n                        value: 'function'\r\n                    };\r\n                }\r\n                let result = {\r\n                    type: 'JsdocTypeFunction',\r\n                    parameters: [],\r\n                    arrow: false,\r\n                    constructor: newKeyword,\r\n                    parenthesis: hasParenthesis\r\n                };\r\n                const value = parser.parseIntermediateType(Precedence.FUNCTION);\r\n                if (allowNamedParameters === undefined) {\r\n                    result.parameters = getUnnamedParameters(value);\r\n                }\r\n                else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\r\n                    result = value;\r\n                    result.constructor = true;\r\n                    return result;\r\n                }\r\n                else {\r\n                    result.parameters = getParameters(value);\r\n                    for (const p of result.parameters) {\r\n                        if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {\r\n                            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\r\n                        }\r\n                    }\r\n                }\r\n                if (parser.consume(':')) {\r\n                    result.returnType = parser.parseType(Precedence.PREFIX);\r\n                }\r\n                else {\r\n                    if (!allowNoReturnType) {\r\n                        throw new Error('function is missing return type');\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        });\r\n    }\r\n\r\n    function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\r\n        return composeParslet({\r\n            name: 'variadicParslet',\r\n            accept: type => type === '...',\r\n            precedence: Precedence.PREFIX,\r\n            parsePrefix: parser => {\r\n                parser.consume('...');\r\n                const brackets = allowEnclosingBrackets && parser.consume('[');\r\n                try {\r\n                    const element = parser.parseType(Precedence.PREFIX);\r\n                    if (brackets && !parser.consume(']')) {\r\n                        throw new Error('Unterminated variadic type. Missing \\']\\'');\r\n                    }\r\n                    return {\r\n                        type: 'JsdocTypeVariadic',\r\n                        element: assertRootResult(element),\r\n                        meta: {\r\n                            position: 'prefix',\r\n                            squareBrackets: brackets\r\n                        }\r\n                    };\r\n                }\r\n                catch (e) {\r\n                    if (e instanceof NoParsletFoundError) {\r\n                        if (brackets) {\r\n                            throw new Error('Empty square brackets for variadic are not allowed.');\r\n                        }\r\n                        return {\r\n                            type: 'JsdocTypeVariadic',\r\n                            meta: {\r\n                                position: undefined,\r\n                                squareBrackets: false\r\n                            }\r\n                        };\r\n                    }\r\n                    else {\r\n                        throw e;\r\n                    }\r\n                }\r\n            },\r\n            parseInfix: allowPostfix\r\n                ? (parser, left) => {\r\n                    parser.consume('...');\r\n                    return {\r\n                        type: 'JsdocTypeVariadic',\r\n                        element: assertRootResult(left),\r\n                        meta: {\r\n                            position: 'suffix',\r\n                            squareBrackets: false\r\n                        }\r\n                    };\r\n                }\r\n                : undefined\r\n        });\r\n    }\r\n\r\n    const symbolParslet = composeParslet({\r\n        name: 'symbolParslet',\r\n        accept: type => type === '(',\r\n        precedence: Precedence.SYMBOL,\r\n        parseInfix: (parser, left) => {\r\n            if (left.type !== 'JsdocTypeName') {\r\n                throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\r\n            }\r\n            parser.consume('(');\r\n            const result = {\r\n                type: 'JsdocTypeSymbol',\r\n                value: left.value\r\n            };\r\n            if (!parser.consume(')')) {\r\n                const next = parser.parseIntermediateType(Precedence.SYMBOL);\r\n                result.element = assertNumberOrVariadicNameResult(next);\r\n                if (!parser.consume(')')) {\r\n                    throw new Error('Symbol does not end after value');\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    });\r\n\r\n    const arrayBracketsParslet = composeParslet({\r\n        name: 'arrayBracketsParslet',\r\n        precedence: Precedence.ARRAY_BRACKETS,\r\n        accept: (type, next) => type === '[' && next === ']',\r\n        parseInfix: (parser, left) => {\r\n            parser.consume('[');\r\n            parser.consume(']');\r\n            return {\r\n                type: 'JsdocTypeGeneric',\r\n                left: {\r\n                    type: 'JsdocTypeName',\r\n                    value: 'Array'\r\n                },\r\n                elements: [\r\n                    assertRootResult(left)\r\n                ],\r\n                meta: {\r\n                    brackets: 'square',\r\n                    dot: false\r\n                }\r\n            };\r\n        }\r\n    });\r\n\r\n    function createObjectParslet({ objectFieldGrammar, allowKeyTypes }) {\r\n        return composeParslet({\r\n            name: 'objectParslet',\r\n            accept: type => type === '{',\r\n            parsePrefix: parser => {\r\n                parser.consume('{');\r\n                const result = {\r\n                    type: 'JsdocTypeObject',\r\n                    meta: {\r\n                        separator: 'comma'\r\n                    },\r\n                    elements: []\r\n                };\r\n                if (!parser.consume('}')) {\r\n                    let separator;\r\n                    const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\r\n                    while (true) {\r\n                        fieldParser.acceptLexerState(parser);\r\n                        let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\r\n                        parser.acceptLexerState(fieldParser);\r\n                        if (field === undefined && allowKeyTypes) {\r\n                            field = parser.parseIntermediateType(Precedence.OBJECT);\r\n                        }\r\n                        let optional = false;\r\n                        if (field.type === 'JsdocTypeNullable') {\r\n                            optional = true;\r\n                            field = field.element;\r\n                        }\r\n                        if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\r\n                            let quote;\r\n                            if (field.type === 'JsdocTypeStringValue') {\r\n                                quote = field.meta.quote;\r\n                            }\r\n                            result.elements.push({\r\n                                type: 'JsdocTypeObjectField',\r\n                                key: field.value.toString(),\r\n                                right: undefined,\r\n                                optional,\r\n                                readonly: false,\r\n                                meta: {\r\n                                    quote\r\n                                }\r\n                            });\r\n                        }\r\n                        else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\r\n                            result.elements.push(field);\r\n                        }\r\n                        else {\r\n                            throw new UnexpectedTypeError(field);\r\n                        }\r\n                        if (parser.lexer.current.startOfLine) {\r\n                            separator = 'linebreak';\r\n                        }\r\n                        else if (parser.consume(',')) {\r\n                            separator = 'comma';\r\n                        }\r\n                        else if (parser.consume(';')) {\r\n                            separator = 'semicolon';\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                        const type = parser.lexer.current.type;\r\n                        if (type === '}') {\r\n                            break;\r\n                        }\r\n                    }\r\n                    result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\r\n                    if (!parser.consume('}')) {\r\n                        throw new Error('Unterminated record type. Missing \\'}\\'');\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        });\r\n    }\r\n\r\n    function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\r\n        return composeParslet({\r\n            name: 'objectFieldParslet',\r\n            precedence: Precedence.KEY_VALUE,\r\n            accept: type => type === ':',\r\n            parseInfix: (parser, left) => {\r\n                var _a;\r\n                let optional = false;\r\n                let readonlyProperty = false;\r\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\r\n                    optional = true;\r\n                    left = left.element;\r\n                }\r\n                if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\r\n                    readonlyProperty = true;\r\n                    left = left.element;\r\n                }\r\n                // object parslet uses a special grammar and for the value we want to switch back to the parent\r\n                const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\r\n                parentParser.acceptLexerState(parser);\r\n                if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||\r\n                    isSquaredProperty(left)) {\r\n                    if (isSquaredProperty(left) && !allowSquaredProperties) {\r\n                        throw new UnexpectedTypeError(left);\r\n                    }\r\n                    parentParser.consume(':');\r\n                    let quote;\r\n                    if (left.type === 'JsdocTypeStringValue') {\r\n                        quote = left.meta.quote;\r\n                    }\r\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\r\n                    parser.acceptLexerState(parentParser);\r\n                    return {\r\n                        type: 'JsdocTypeObjectField',\r\n                        key: isSquaredProperty(left) ? left : left.value.toString(),\r\n                        right,\r\n                        optional,\r\n                        readonly: readonlyProperty,\r\n                        meta: {\r\n                            quote\r\n                        }\r\n                    };\r\n                }\r\n                else {\r\n                    if (!allowKeyTypes) {\r\n                        throw new UnexpectedTypeError(left);\r\n                    }\r\n                    parentParser.consume(':');\r\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\r\n                    parser.acceptLexerState(parentParser);\r\n                    return {\r\n                        type: 'JsdocTypeJsdocObjectField',\r\n                        left: assertRootResult(left),\r\n                        right\r\n                    };\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    function createKeyValueParslet({ allowOptional, allowVariadic }) {\r\n        return composeParslet({\r\n            name: 'keyValueParslet',\r\n            precedence: Precedence.KEY_VALUE,\r\n            accept: type => type === ':',\r\n            parseInfix: (parser, left) => {\r\n                let optional = false;\r\n                let variadic = false;\r\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\r\n                    optional = true;\r\n                    left = left.element;\r\n                }\r\n                if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\r\n                    variadic = true;\r\n                    left = left.element;\r\n                }\r\n                if (left.type !== 'JsdocTypeName') {\r\n                    throw new UnexpectedTypeError(left);\r\n                }\r\n                parser.consume(':');\r\n                const right = parser.parseType(Precedence.KEY_VALUE);\r\n                return {\r\n                    type: 'JsdocTypeKeyValue',\r\n                    key: left.value,\r\n                    right,\r\n                    optional,\r\n                    variadic\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    const jsdocBaseGrammar = [\r\n        ...baseGrammar,\r\n        createFunctionParslet({\r\n            allowWithoutParenthesis: true,\r\n            allowNamedParameters: ['this', 'new'],\r\n            allowNoReturnType: true,\r\n            allowNewAsFunctionKeyword: false\r\n        }),\r\n        stringValueParslet,\r\n        createSpecialNamePathParslet({\r\n            allowedTypes: ['module', 'external', 'event'],\r\n            pathGrammar\r\n        }),\r\n        createVariadicParslet({\r\n            allowEnclosingBrackets: true,\r\n            allowPostfix: true\r\n        }),\r\n        createNameParslet({\r\n            allowedAdditionalTokens: ['keyof']\r\n        }),\r\n        symbolParslet,\r\n        arrayBracketsParslet,\r\n        createNamePathParslet({\r\n            allowSquareBracketsOnAnyType: false,\r\n            allowJsdocNamePaths: true,\r\n            pathGrammar\r\n        })\r\n    ];\r\n    const jsdocGrammar = [\r\n        ...jsdocBaseGrammar,\r\n        createObjectParslet({\r\n            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\r\n            // we leave out the object type deliberately\r\n            objectFieldGrammar: [\r\n                createNameParslet({\r\n                    allowedAdditionalTokens: ['module', 'in']\r\n                }),\r\n                createObjectFieldParslet({\r\n                    allowSquaredProperties: false,\r\n                    allowKeyTypes: true,\r\n                    allowOptional: false,\r\n                    allowReadonly: false\r\n                }),\r\n                ...jsdocBaseGrammar\r\n            ],\r\n            allowKeyTypes: true\r\n        }),\r\n        createKeyValueParslet({\r\n            allowOptional: true,\r\n            allowVariadic: true\r\n        })\r\n    ];\r\n\r\n    const typeOfParslet = composeParslet({\r\n        name: 'typeOfParslet',\r\n        accept: type => type === 'typeof',\r\n        parsePrefix: parser => {\r\n            parser.consume('typeof');\r\n            return {\r\n                type: 'JsdocTypeTypeof',\r\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\r\n            };\r\n        }\r\n    });\r\n\r\n    const objectFieldGrammar$1 = [\r\n        createNameParslet({\r\n            allowedAdditionalTokens: ['module', 'keyof', 'event', 'external', 'in']\r\n        }),\r\n        nullableParslet,\r\n        optionalParslet,\r\n        stringValueParslet,\r\n        numberParslet,\r\n        createObjectFieldParslet({\r\n            allowSquaredProperties: false,\r\n            allowKeyTypes: false,\r\n            allowOptional: false,\r\n            allowReadonly: false\r\n        })\r\n    ];\r\n    const closureGrammar = [\r\n        ...baseGrammar,\r\n        createObjectParslet({\r\n            allowKeyTypes: false,\r\n            objectFieldGrammar: objectFieldGrammar$1\r\n        }),\r\n        createNameParslet({\r\n            allowedAdditionalTokens: ['event', 'external', 'in']\r\n        }),\r\n        typeOfParslet,\r\n        createFunctionParslet({\r\n            allowWithoutParenthesis: false,\r\n            allowNamedParameters: ['this', 'new'],\r\n            allowNoReturnType: true,\r\n            allowNewAsFunctionKeyword: false\r\n        }),\r\n        createVariadicParslet({\r\n            allowEnclosingBrackets: false,\r\n            allowPostfix: false\r\n        }),\r\n        // additional name parslet is needed for some special cases\r\n        createNameParslet({\r\n            allowedAdditionalTokens: ['keyof']\r\n        }),\r\n        createSpecialNamePathParslet({\r\n            allowedTypes: ['module'],\r\n            pathGrammar\r\n        }),\r\n        createNamePathParslet({\r\n            allowSquareBracketsOnAnyType: false,\r\n            allowJsdocNamePaths: true,\r\n            pathGrammar\r\n        }),\r\n        createKeyValueParslet({\r\n            allowOptional: false,\r\n            allowVariadic: false\r\n        }),\r\n        symbolParslet\r\n    ];\r\n\r\n    const assertsParslet = composeParslet({\r\n        name: 'assertsParslet',\r\n        accept: type => type === 'asserts',\r\n        parsePrefix: (parser) => {\r\n            parser.consume('asserts');\r\n            const left = parser.parseIntermediateType(Precedence.SYMBOL);\r\n            if (left.type !== 'JsdocTypeName') {\r\n                throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\r\n            }\r\n            parser.consume('is');\r\n            return {\r\n                type: 'JsdocTypeAsserts',\r\n                left,\r\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\r\n            };\r\n        }\r\n    });\r\n\r\n    function createTupleParslet({ allowQuestionMark }) {\r\n        return composeParslet({\r\n            name: 'tupleParslet',\r\n            accept: type => type === '[',\r\n            parsePrefix: parser => {\r\n                parser.consume('[');\r\n                const result = {\r\n                    type: 'JsdocTypeTuple',\r\n                    elements: []\r\n                };\r\n                if (parser.consume(']')) {\r\n                    return result;\r\n                }\r\n                const typeList = parser.parseIntermediateType(Precedence.ALL);\r\n                if (typeList.type === 'JsdocTypeParameterList') {\r\n                    if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\r\n                        result.elements = typeList.elements.map(assertPlainKeyValueResult);\r\n                    }\r\n                    else {\r\n                        result.elements = typeList.elements.map(assertRootResult);\r\n                    }\r\n                }\r\n                else {\r\n                    if (typeList.type === 'JsdocTypeKeyValue') {\r\n                        result.elements = [assertPlainKeyValueResult(typeList)];\r\n                    }\r\n                    else {\r\n                        result.elements = [assertRootResult(typeList)];\r\n                    }\r\n                }\r\n                if (!parser.consume(']')) {\r\n                    throw new Error('Unterminated \\'[\\'');\r\n                }\r\n                if (!allowQuestionMark && result.elements.some((e) => e.type === 'JsdocTypeUnknown')) {\r\n                    throw new Error('Question mark in tuple not allowed');\r\n                }\r\n                return result;\r\n            }\r\n        });\r\n    }\r\n\r\n    const keyOfParslet = composeParslet({\r\n        name: 'keyOfParslet',\r\n        accept: type => type === 'keyof',\r\n        parsePrefix: parser => {\r\n            parser.consume('keyof');\r\n            return {\r\n                type: 'JsdocTypeKeyof',\r\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\r\n            };\r\n        }\r\n    });\r\n\r\n    const importParslet = composeParslet({\r\n        name: 'importParslet',\r\n        accept: type => type === 'import',\r\n        parsePrefix: parser => {\r\n            parser.consume('import');\r\n            if (!parser.consume('(')) {\r\n                throw new Error('Missing parenthesis after import keyword');\r\n            }\r\n            const path = parser.parseType(Precedence.PREFIX);\r\n            if (path.type !== 'JsdocTypeStringValue') {\r\n                throw new Error('Only string values are allowed as paths for imports');\r\n            }\r\n            if (!parser.consume(')')) {\r\n                throw new Error('Missing closing parenthesis after import keyword');\r\n            }\r\n            return {\r\n                type: 'JsdocTypeImport',\r\n                element: path\r\n            };\r\n        }\r\n    });\r\n\r\n    const readonlyPropertyParslet = composeParslet({\r\n        name: 'readonlyPropertyParslet',\r\n        accept: type => type === 'readonly',\r\n        parsePrefix: parser => {\r\n            parser.consume('readonly');\r\n            return {\r\n                type: 'JsdocTypeReadonlyProperty',\r\n                element: parser.parseType(Precedence.KEY_VALUE)\r\n            };\r\n        }\r\n    });\r\n\r\n    const arrowFunctionParslet = composeParslet({\r\n        name: 'arrowFunctionParslet',\r\n        precedence: Precedence.ARROW,\r\n        accept: type => type === '=>',\r\n        parseInfix: (parser, left) => {\r\n            parser.consume('=>');\r\n            return {\r\n                type: 'JsdocTypeFunction',\r\n                parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\r\n                arrow: true,\r\n                constructor: false,\r\n                parenthesis: true,\r\n                returnType: parser.parseType(Precedence.OBJECT)\r\n            };\r\n        }\r\n    });\r\n\r\n    const intersectionParslet = composeParslet({\r\n        name: 'intersectionParslet',\r\n        accept: type => type === '&',\r\n        precedence: Precedence.INTERSECTION,\r\n        parseInfix: (parser, left) => {\r\n            parser.consume('&');\r\n            const elements = [];\r\n            do {\r\n                elements.push(parser.parseType(Precedence.INTERSECTION));\r\n            } while (parser.consume('&'));\r\n            return {\r\n                type: 'JsdocTypeIntersection',\r\n                elements: [assertRootResult(left), ...elements]\r\n            };\r\n        }\r\n    });\r\n\r\n    const predicateParslet = composeParslet({\r\n        name: 'predicateParslet',\r\n        precedence: Precedence.INFIX,\r\n        accept: type => type === 'is',\r\n        parseInfix: (parser, left) => {\r\n            if (left.type !== 'JsdocTypeName') {\r\n                throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\r\n            }\r\n            parser.consume('is');\r\n            return {\r\n                type: 'JsdocTypePredicate',\r\n                left,\r\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\r\n            };\r\n        }\r\n    });\r\n\r\n    const objectSquaredPropertyParslet = composeParslet({\r\n        name: 'objectSquareBracketPropertyParslet',\r\n        accept: type => type === '[',\r\n        parsePrefix: parser => {\r\n            if (parser.baseParser === undefined) {\r\n                throw new Error('Only allowed inside object grammar');\r\n            }\r\n            parser.consume('[');\r\n            const key = parser.lexer.current.text;\r\n            parser.consume('Identifier');\r\n            let result;\r\n            if (parser.consume(':')) {\r\n                const parentParser = parser.baseParser;\r\n                parentParser.acceptLexerState(parser);\r\n                result = {\r\n                    type: 'JsdocTypeIndexSignature',\r\n                    key,\r\n                    right: parentParser.parseType(Precedence.INDEX_BRACKETS)\r\n                };\r\n                parser.acceptLexerState(parentParser);\r\n            }\r\n            else if (parser.consume('in')) {\r\n                const parentParser = parser.baseParser;\r\n                parentParser.acceptLexerState(parser);\r\n                result = {\r\n                    type: 'JsdocTypeMappedType',\r\n                    key,\r\n                    right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\r\n                };\r\n                parser.acceptLexerState(parentParser);\r\n            }\r\n            else {\r\n                throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\r\n            }\r\n            if (!parser.consume(']')) {\r\n                throw new Error('Unterminated square brackets');\r\n            }\r\n            return result;\r\n        }\r\n    });\r\n\r\n    const objectFieldGrammar = [\r\n        readonlyPropertyParslet,\r\n        createNameParslet({\r\n            allowedAdditionalTokens: ['module', 'event', 'keyof', 'event', 'external', 'in']\r\n        }),\r\n        nullableParslet,\r\n        optionalParslet,\r\n        stringValueParslet,\r\n        numberParslet,\r\n        createObjectFieldParslet({\r\n            allowSquaredProperties: true,\r\n            allowKeyTypes: false,\r\n            allowOptional: true,\r\n            allowReadonly: true\r\n        }),\r\n        objectSquaredPropertyParslet\r\n    ];\r\n    const typescriptGrammar = [\r\n        ...baseGrammar,\r\n        createObjectParslet({\r\n            allowKeyTypes: false,\r\n            objectFieldGrammar\r\n        }),\r\n        typeOfParslet,\r\n        keyOfParslet,\r\n        importParslet,\r\n        stringValueParslet,\r\n        createFunctionParslet({\r\n            allowWithoutParenthesis: true,\r\n            allowNoReturnType: false,\r\n            allowNamedParameters: ['this', 'new', 'args'],\r\n            allowNewAsFunctionKeyword: true\r\n        }),\r\n        createTupleParslet({\r\n            allowQuestionMark: false\r\n        }),\r\n        createVariadicParslet({\r\n            allowEnclosingBrackets: false,\r\n            allowPostfix: false\r\n        }),\r\n        assertsParslet,\r\n        createNameParslet({\r\n            allowedAdditionalTokens: ['event', 'external', 'in']\r\n        }),\r\n        createSpecialNamePathParslet({\r\n            allowedTypes: ['module'],\r\n            pathGrammar\r\n        }),\r\n        arrayBracketsParslet,\r\n        arrowFunctionParslet,\r\n        createNamePathParslet({\r\n            allowSquareBracketsOnAnyType: true,\r\n            allowJsdocNamePaths: false,\r\n            pathGrammar\r\n        }),\r\n        intersectionParslet,\r\n        predicateParslet,\r\n        createKeyValueParslet({\r\n            allowVariadic: true,\r\n            allowOptional: true\r\n        })\r\n    ];\r\n\r\n    /**\r\n     * This function parses the given expression in the given mode and produces a {@link RootResult}.\r\n     * @param expression\r\n     * @param mode\r\n     */\r\n    function parse(expression, mode) {\r\n        switch (mode) {\r\n            case 'closure':\r\n                return (new Parser(closureGrammar, expression)).parse();\r\n            case 'jsdoc':\r\n                return (new Parser(jsdocGrammar, expression)).parse();\r\n            case 'typescript':\r\n                return (new Parser(typescriptGrammar, expression)).parse();\r\n        }\r\n    }\r\n    /**\r\n     * This function tries to parse the given expression in multiple modes and returns the first successful\r\n     * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\r\n     * no mode was successful it throws the error that was produced by the last parsing attempt.\r\n     * @param expression\r\n     * @param modes\r\n     */\r\n    function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {\r\n        let error;\r\n        for (const mode of modes) {\r\n            try {\r\n                return parse(expression, mode);\r\n            }\r\n            catch (e) {\r\n                error = e;\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n\r\n    function transform(rules, parseResult) {\r\n        const rule = rules[parseResult.type];\r\n        if (rule === undefined) {\r\n            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\r\n        }\r\n        return rule(parseResult, aParseResult => transform(rules, aParseResult));\r\n    }\r\n    function notAvailableTransform(parseResult) {\r\n        throw new Error('This transform is not available. Are you trying the correct parsing mode?');\r\n    }\r\n    function extractSpecialParams(source) {\r\n        const result = {\r\n            params: []\r\n        };\r\n        for (const param of source.parameters) {\r\n            if (param.type === 'JsdocTypeKeyValue') {\r\n                if (param.key === 'this') {\r\n                    result.this = param.right;\r\n                }\r\n                else if (param.key === 'new') {\r\n                    result.new = param.right;\r\n                }\r\n                else {\r\n                    result.params.push(param);\r\n                }\r\n            }\r\n            else {\r\n                result.params.push(param);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function applyPosition(position, target, value) {\r\n        return position === 'prefix' ? value + target : target + value;\r\n    }\r\n    function quote(value, quote) {\r\n        switch (quote) {\r\n            case 'double':\r\n                return `\"${value}\"`;\r\n            case 'single':\r\n                return `'${value}'`;\r\n            case undefined:\r\n                return value;\r\n        }\r\n    }\r\n    function stringifyRules() {\r\n        return {\r\n            JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\r\n            JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\r\n            JsdocTypeFunction: (result, transform) => {\r\n                if (!result.arrow) {\r\n                    let stringified = result.constructor ? 'new' : 'function';\r\n                    if (!result.parenthesis) {\r\n                        return stringified;\r\n                    }\r\n                    stringified += `(${result.parameters.map(transform).join(', ')})`;\r\n                    if (result.returnType !== undefined) {\r\n                        stringified += `: ${transform(result.returnType)}`;\r\n                    }\r\n                    return stringified;\r\n                }\r\n                else {\r\n                    if (result.returnType === undefined) {\r\n                        throw new Error('Arrow function needs a return type.');\r\n                    }\r\n                    let stringified = `(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\r\n                    if (result.constructor) {\r\n                        stringified = 'new ' + stringified;\r\n                    }\r\n                    return stringified;\r\n                }\r\n            },\r\n            JsdocTypeName: result => result.value,\r\n            JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\r\n            JsdocTypeVariadic: (result, transform) => result.meta.position === undefined\r\n                ? '...'\r\n                : applyPosition(result.meta.position, transform(result.element), '...'),\r\n            JsdocTypeNamePath: (result, transform) => {\r\n                const left = transform(result.left);\r\n                const right = transform(result.right);\r\n                switch (result.pathType) {\r\n                    case 'inner':\r\n                        return `${left}~${right}`;\r\n                    case 'instance':\r\n                        return `${left}#${right}`;\r\n                    case 'property':\r\n                        return `${left}.${right}`;\r\n                    case 'property-brackets':\r\n                        return `${left}[${right}]`;\r\n                }\r\n            },\r\n            JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\r\n            JsdocTypeAny: () => '*',\r\n            JsdocTypeGeneric: (result, transform) => {\r\n                if (result.meta.brackets === 'square') {\r\n                    const element = result.elements[0];\r\n                    const transformed = transform(element);\r\n                    if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\r\n                        return `(${transformed})[]`;\r\n                    }\r\n                    else {\r\n                        return `${transformed}[]`;\r\n                    }\r\n                }\r\n                else {\r\n                    return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.elements.map(transform).join(', ')}>`;\r\n                }\r\n            },\r\n            JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\r\n            JsdocTypeObjectField: (result, transform) => {\r\n                let text = '';\r\n                if (result.readonly) {\r\n                    text += 'readonly ';\r\n                }\r\n                if (typeof result.key === 'string') {\r\n                    text += quote(result.key, result.meta.quote);\r\n                }\r\n                else {\r\n                    text += transform(result.key);\r\n                }\r\n                if (result.optional) {\r\n                    text += '?';\r\n                }\r\n                if (result.right === undefined) {\r\n                    return text;\r\n                }\r\n                else {\r\n                    return text + `: ${transform(result.right)}`;\r\n                }\r\n            },\r\n            JsdocTypeJsdocObjectField: (result, transform) => {\r\n                return `${transform(result.left)}: ${transform(result.right)}`;\r\n            },\r\n            JsdocTypeKeyValue: (result, transform) => {\r\n                let text = result.key;\r\n                if (result.optional) {\r\n                    text += '?';\r\n                }\r\n                if (result.variadic) {\r\n                    text = '...' + text;\r\n                }\r\n                if (result.right === undefined) {\r\n                    return text;\r\n                }\r\n                else {\r\n                    return text + `: ${transform(result.right)}`;\r\n                }\r\n            },\r\n            JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\r\n            JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\r\n            JsdocTypeNull: () => 'null',\r\n            JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\r\n            JsdocTypeNumber: result => result.value.toString(),\r\n            JsdocTypeObject: (result, transform) => `{${result.elements.map(transform).join((result.meta.separator === 'comma' ? ',' : ';') + ' ')}}`,\r\n            JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\r\n            JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\r\n            JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\r\n            JsdocTypeUndefined: () => 'undefined',\r\n            JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\r\n            JsdocTypeUnknown: () => '?',\r\n            JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\r\n            JsdocTypeProperty: result => quote(result.value, result.meta.quote),\r\n            JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\r\n            JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\r\n            JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\r\n            JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`\r\n        };\r\n    }\r\n    const storedStringifyRules = stringifyRules();\r\n    function stringify(result) {\r\n        return transform(storedStringifyRules, result);\r\n    }\r\n\r\n    const reservedWords = [\r\n        'null',\r\n        'true',\r\n        'false',\r\n        'break',\r\n        'case',\r\n        'catch',\r\n        'class',\r\n        'const',\r\n        'continue',\r\n        'debugger',\r\n        'default',\r\n        'delete',\r\n        'do',\r\n        'else',\r\n        'export',\r\n        'extends',\r\n        'finally',\r\n        'for',\r\n        'function',\r\n        'if',\r\n        'import',\r\n        'in',\r\n        'instanceof',\r\n        'new',\r\n        'return',\r\n        'super',\r\n        'switch',\r\n        'this',\r\n        'throw',\r\n        'try',\r\n        'typeof',\r\n        'var',\r\n        'void',\r\n        'while',\r\n        'with',\r\n        'yield'\r\n    ];\r\n    function makeName(value) {\r\n        const result = {\r\n            type: 'NameExpression',\r\n            name: value\r\n        };\r\n        if (reservedWords.includes(value)) {\r\n            result.reservedWord = true;\r\n        }\r\n        return result;\r\n    }\r\n    const catharsisTransformRules = {\r\n        JsdocTypeOptional: (result, transform) => {\r\n            const transformed = transform(result.element);\r\n            transformed.optional = true;\r\n            return transformed;\r\n        },\r\n        JsdocTypeNullable: (result, transform) => {\r\n            const transformed = transform(result.element);\r\n            transformed.nullable = true;\r\n            return transformed;\r\n        },\r\n        JsdocTypeNotNullable: (result, transform) => {\r\n            const transformed = transform(result.element);\r\n            transformed.nullable = false;\r\n            return transformed;\r\n        },\r\n        JsdocTypeVariadic: (result, transform) => {\r\n            if (result.element === undefined) {\r\n                throw new Error('dots without value are not allowed in catharsis mode');\r\n            }\r\n            const transformed = transform(result.element);\r\n            transformed.repeatable = true;\r\n            return transformed;\r\n        },\r\n        JsdocTypeAny: () => ({\r\n            type: 'AllLiteral'\r\n        }),\r\n        JsdocTypeNull: () => ({\r\n            type: 'NullLiteral'\r\n        }),\r\n        JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\r\n        JsdocTypeUndefined: () => ({\r\n            type: 'UndefinedLiteral'\r\n        }),\r\n        JsdocTypeUnknown: () => ({\r\n            type: 'UnknownLiteral'\r\n        }),\r\n        JsdocTypeFunction: (result, transform) => {\r\n            const params = extractSpecialParams(result);\r\n            const transformed = {\r\n                type: 'FunctionType',\r\n                params: params.params.map(transform)\r\n            };\r\n            if (params.this !== undefined) {\r\n                transformed.this = transform(params.this);\r\n            }\r\n            if (params.new !== undefined) {\r\n                transformed.new = transform(params.new);\r\n            }\r\n            if (result.returnType !== undefined) {\r\n                transformed.result = transform(result.returnType);\r\n            }\r\n            return transformed;\r\n        },\r\n        JsdocTypeGeneric: (result, transform) => ({\r\n            type: 'TypeApplication',\r\n            applications: result.elements.map(o => transform(o)),\r\n            expression: transform(result.left)\r\n        }),\r\n        JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\r\n        JsdocTypeName: result => {\r\n            if (result.value !== 'function') {\r\n                return makeName(result.value);\r\n            }\r\n            else {\r\n                return {\r\n                    type: 'FunctionType',\r\n                    params: []\r\n                };\r\n            }\r\n        },\r\n        JsdocTypeNumber: result => makeName(result.value.toString()),\r\n        JsdocTypeObject: (result, transform) => {\r\n            const transformed = {\r\n                type: 'RecordType',\r\n                fields: []\r\n            };\r\n            for (const field of result.elements) {\r\n                if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\r\n                    transformed.fields.push({\r\n                        type: 'FieldType',\r\n                        key: transform(field),\r\n                        value: undefined\r\n                    });\r\n                }\r\n                else {\r\n                    transformed.fields.push(transform(field));\r\n                }\r\n            }\r\n            return transformed;\r\n        },\r\n        JsdocTypeObjectField: (result, transform) => {\r\n            if (typeof result.key !== 'string') {\r\n                throw new Error('Index signatures and mapped types are not supported');\r\n            }\r\n            return {\r\n                type: 'FieldType',\r\n                key: makeName(quote(result.key, result.meta.quote)),\r\n                value: result.right === undefined ? undefined : transform(result.right)\r\n            };\r\n        },\r\n        JsdocTypeJsdocObjectField: (result, transform) => ({\r\n            type: 'FieldType',\r\n            key: transform(result.left),\r\n            value: transform(result.right)\r\n        }),\r\n        JsdocTypeUnion: (result, transform) => ({\r\n            type: 'TypeUnion',\r\n            elements: result.elements.map(e => transform(e))\r\n        }),\r\n        JsdocTypeKeyValue: (result, transform) => {\r\n            return {\r\n                type: 'FieldType',\r\n                key: makeName(result.key),\r\n                value: result.right === undefined ? undefined : transform(result.right)\r\n            };\r\n        },\r\n        JsdocTypeNamePath: (result, transform) => {\r\n            const leftResult = transform(result.left);\r\n            let rightValue;\r\n            if (result.right.type === 'JsdocTypeSpecialNamePath') {\r\n                rightValue = transform(result.right).name;\r\n            }\r\n            else {\r\n                rightValue = quote(result.right.value, result.right.meta.quote);\r\n            }\r\n            const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\r\n            return makeName(`${leftResult.name}${joiner}${rightValue}`);\r\n        },\r\n        JsdocTypeSymbol: result => {\r\n            let value = '';\r\n            let element = result.element;\r\n            let trailingDots = false;\r\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\r\n                if (element.meta.position === 'prefix') {\r\n                    value = '...';\r\n                }\r\n                else {\r\n                    trailingDots = true;\r\n                }\r\n                element = element.element;\r\n            }\r\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\r\n                value += element.value;\r\n            }\r\n            else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\r\n                value += element.value.toString();\r\n            }\r\n            if (trailingDots) {\r\n                value += '...';\r\n            }\r\n            return makeName(`${result.value}(${value})`);\r\n        },\r\n        JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\r\n        JsdocTypeMappedType: notAvailableTransform,\r\n        JsdocTypeIndexSignature: notAvailableTransform,\r\n        JsdocTypeImport: notAvailableTransform,\r\n        JsdocTypeKeyof: notAvailableTransform,\r\n        JsdocTypeTuple: notAvailableTransform,\r\n        JsdocTypeTypeof: notAvailableTransform,\r\n        JsdocTypeIntersection: notAvailableTransform,\r\n        JsdocTypeProperty: notAvailableTransform,\r\n        JsdocTypePredicate: notAvailableTransform,\r\n        JsdocTypeAsserts: notAvailableTransform\r\n    };\r\n    function catharsisTransform(result) {\r\n        return transform(catharsisTransformRules, result);\r\n    }\r\n\r\n    function getQuoteStyle(quote) {\r\n        switch (quote) {\r\n            case undefined:\r\n                return 'none';\r\n            case 'single':\r\n                return 'single';\r\n            case 'double':\r\n                return 'double';\r\n        }\r\n    }\r\n    function getMemberType(type) {\r\n        switch (type) {\r\n            case 'inner':\r\n                return 'INNER_MEMBER';\r\n            case 'instance':\r\n                return 'INSTANCE_MEMBER';\r\n            case 'property':\r\n                return 'MEMBER';\r\n            case 'property-brackets':\r\n                return 'MEMBER';\r\n        }\r\n    }\r\n    function nestResults(type, results) {\r\n        if (results.length === 2) {\r\n            return {\r\n                type,\r\n                left: results[0],\r\n                right: results[1]\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                type,\r\n                left: results[0],\r\n                right: nestResults(type, results.slice(1))\r\n            };\r\n        }\r\n    }\r\n    const jtpRules = {\r\n        JsdocTypeOptional: (result, transform) => ({\r\n            type: 'OPTIONAL',\r\n            value: transform(result.element),\r\n            meta: {\r\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\r\n            }\r\n        }),\r\n        JsdocTypeNullable: (result, transform) => ({\r\n            type: 'NULLABLE',\r\n            value: transform(result.element),\r\n            meta: {\r\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\r\n            }\r\n        }),\r\n        JsdocTypeNotNullable: (result, transform) => ({\r\n            type: 'NOT_NULLABLE',\r\n            value: transform(result.element),\r\n            meta: {\r\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\r\n            }\r\n        }),\r\n        JsdocTypeVariadic: (result, transform) => {\r\n            const transformed = {\r\n                type: 'VARIADIC',\r\n                meta: {\r\n                    syntax: result.meta.position === 'prefix'\r\n                        ? 'PREFIX_DOTS'\r\n                        : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\r\n                }\r\n            };\r\n            if (result.element !== undefined) {\r\n                transformed.value = transform(result.element);\r\n            }\r\n            return transformed;\r\n        },\r\n        JsdocTypeName: result => ({\r\n            type: 'NAME',\r\n            name: result.value\r\n        }),\r\n        JsdocTypeTypeof: (result, transform) => ({\r\n            type: 'TYPE_QUERY',\r\n            name: transform(result.element)\r\n        }),\r\n        JsdocTypeTuple: (result, transform) => ({\r\n            type: 'TUPLE',\r\n            entries: result.elements.map(transform)\r\n        }),\r\n        JsdocTypeKeyof: (result, transform) => ({\r\n            type: 'KEY_QUERY',\r\n            value: transform(result.element)\r\n        }),\r\n        JsdocTypeImport: result => ({\r\n            type: 'IMPORT',\r\n            path: {\r\n                type: 'STRING_VALUE',\r\n                quoteStyle: getQuoteStyle(result.element.meta.quote),\r\n                string: result.element.value\r\n            }\r\n        }),\r\n        JsdocTypeUndefined: () => ({\r\n            type: 'NAME',\r\n            name: 'undefined'\r\n        }),\r\n        JsdocTypeAny: () => ({\r\n            type: 'ANY'\r\n        }),\r\n        JsdocTypeFunction: (result, transform) => {\r\n            const specialParams = extractSpecialParams(result);\r\n            const transformed = {\r\n                type: result.arrow ? 'ARROW' : 'FUNCTION',\r\n                params: specialParams.params.map(param => {\r\n                    if (param.type === 'JsdocTypeKeyValue') {\r\n                        if (param.right === undefined) {\r\n                            throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\r\n                        }\r\n                        return {\r\n                            type: 'NAMED_PARAMETER',\r\n                            name: param.key,\r\n                            typeName: transform(param.right)\r\n                        };\r\n                    }\r\n                    else {\r\n                        return transform(param);\r\n                    }\r\n                }),\r\n                new: null,\r\n                returns: null\r\n            };\r\n            if (specialParams.this !== undefined) {\r\n                transformed.this = transform(specialParams.this);\r\n            }\r\n            else if (!result.arrow) {\r\n                transformed.this = null;\r\n            }\r\n            if (specialParams.new !== undefined) {\r\n                transformed.new = transform(specialParams.new);\r\n            }\r\n            if (result.returnType !== undefined) {\r\n                transformed.returns = transform(result.returnType);\r\n            }\r\n            return transformed;\r\n        },\r\n        JsdocTypeGeneric: (result, transform) => {\r\n            const transformed = {\r\n                type: 'GENERIC',\r\n                subject: transform(result.left),\r\n                objects: result.elements.map(transform),\r\n                meta: {\r\n                    syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\r\n                }\r\n            };\r\n            if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\r\n                transformed.objects[0] = {\r\n                    type: 'NAME',\r\n                    name: 'function'\r\n                };\r\n            }\r\n            return transformed;\r\n        },\r\n        JsdocTypeObjectField: (result, transform) => {\r\n            if (typeof result.key !== 'string') {\r\n                throw new Error('Index signatures and mapped types are not supported');\r\n            }\r\n            if (result.right === undefined) {\r\n                return {\r\n                    type: 'RECORD_ENTRY',\r\n                    key: result.key,\r\n                    quoteStyle: getQuoteStyle(result.meta.quote),\r\n                    value: null,\r\n                    readonly: false\r\n                };\r\n            }\r\n            let right = transform(result.right);\r\n            if (result.optional) {\r\n                right = {\r\n                    type: 'OPTIONAL',\r\n                    value: right,\r\n                    meta: {\r\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\r\n                    }\r\n                };\r\n            }\r\n            return {\r\n                type: 'RECORD_ENTRY',\r\n                key: result.key.toString(),\r\n                quoteStyle: getQuoteStyle(result.meta.quote),\r\n                value: right,\r\n                readonly: false\r\n            };\r\n        },\r\n        JsdocTypeJsdocObjectField: () => {\r\n            throw new Error('Keys may not be typed in jsdoctypeparser.');\r\n        },\r\n        JsdocTypeKeyValue: (result, transform) => {\r\n            if (result.right === undefined) {\r\n                return {\r\n                    type: 'RECORD_ENTRY',\r\n                    key: result.key,\r\n                    quoteStyle: 'none',\r\n                    value: null,\r\n                    readonly: false\r\n                };\r\n            }\r\n            let right = transform(result.right);\r\n            if (result.optional) {\r\n                right = {\r\n                    type: 'OPTIONAL',\r\n                    value: right,\r\n                    meta: {\r\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\r\n                    }\r\n                };\r\n            }\r\n            return {\r\n                type: 'RECORD_ENTRY',\r\n                key: result.key,\r\n                quoteStyle: 'none',\r\n                value: right,\r\n                readonly: false\r\n            };\r\n        },\r\n        JsdocTypeObject: (result, transform) => {\r\n            const entries = [];\r\n            for (const field of result.elements) {\r\n                if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\r\n                    entries.push(transform(field));\r\n                }\r\n            }\r\n            return {\r\n                type: 'RECORD',\r\n                entries\r\n            };\r\n        },\r\n        JsdocTypeSpecialNamePath: result => {\r\n            if (result.specialType !== 'module') {\r\n                throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\r\n            }\r\n            return {\r\n                type: 'MODULE',\r\n                value: {\r\n                    type: 'FILE_PATH',\r\n                    quoteStyle: getQuoteStyle(result.meta.quote),\r\n                    path: result.value\r\n                }\r\n            };\r\n        },\r\n        JsdocTypeNamePath: (result, transform) => {\r\n            let hasEventPrefix = false;\r\n            let name;\r\n            let quoteStyle;\r\n            if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\r\n                hasEventPrefix = true;\r\n                name = result.right.value;\r\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\r\n            }\r\n            else {\r\n                name = result.right.value;\r\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\r\n            }\r\n            const transformed = {\r\n                type: getMemberType(result.pathType),\r\n                owner: transform(result.left),\r\n                name,\r\n                quoteStyle,\r\n                hasEventPrefix\r\n            };\r\n            if (transformed.owner.type === 'MODULE') {\r\n                const tModule = transformed.owner;\r\n                transformed.owner = transformed.owner.value;\r\n                tModule.value = transformed;\r\n                return tModule;\r\n            }\r\n            else {\r\n                return transformed;\r\n            }\r\n        },\r\n        JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\r\n        JsdocTypeParenthesis: (result, transform) => ({\r\n            type: 'PARENTHESIS',\r\n            value: transform(assertRootResult(result.element))\r\n        }),\r\n        JsdocTypeNull: () => ({\r\n            type: 'NAME',\r\n            name: 'null'\r\n        }),\r\n        JsdocTypeUnknown: () => ({\r\n            type: 'UNKNOWN'\r\n        }),\r\n        JsdocTypeStringValue: result => ({\r\n            type: 'STRING_VALUE',\r\n            quoteStyle: getQuoteStyle(result.meta.quote),\r\n            string: result.value\r\n        }),\r\n        JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\r\n        JsdocTypeNumber: result => ({\r\n            type: 'NUMBER_VALUE',\r\n            number: result.value.toString()\r\n        }),\r\n        JsdocTypeSymbol: notAvailableTransform,\r\n        JsdocTypeProperty: notAvailableTransform,\r\n        JsdocTypePredicate: notAvailableTransform,\r\n        JsdocTypeMappedType: notAvailableTransform,\r\n        JsdocTypeIndexSignature: notAvailableTransform,\r\n        JsdocTypeAsserts: notAvailableTransform\r\n    };\r\n    function jtpTransform(result) {\r\n        return transform(jtpRules, result);\r\n    }\r\n\r\n    function identityTransformRules() {\r\n        return {\r\n            JsdocTypeIntersection: (result, transform) => ({\r\n                type: 'JsdocTypeIntersection',\r\n                elements: result.elements.map(transform)\r\n            }),\r\n            JsdocTypeGeneric: (result, transform) => ({\r\n                type: 'JsdocTypeGeneric',\r\n                left: transform(result.left),\r\n                elements: result.elements.map(transform),\r\n                meta: {\r\n                    dot: result.meta.dot,\r\n                    brackets: result.meta.brackets\r\n                }\r\n            }),\r\n            JsdocTypeNullable: result => result,\r\n            JsdocTypeUnion: (result, transform) => ({\r\n                type: 'JsdocTypeUnion',\r\n                elements: result.elements.map(transform)\r\n            }),\r\n            JsdocTypeUnknown: result => result,\r\n            JsdocTypeUndefined: result => result,\r\n            JsdocTypeTypeof: (result, transform) => ({\r\n                type: 'JsdocTypeTypeof',\r\n                element: transform(result.element)\r\n            }),\r\n            JsdocTypeSymbol: (result, transform) => {\r\n                const transformed = {\r\n                    type: 'JsdocTypeSymbol',\r\n                    value: result.value\r\n                };\r\n                if (result.element !== undefined) {\r\n                    transformed.element = transform(result.element);\r\n                }\r\n                return transformed;\r\n            },\r\n            JsdocTypeOptional: (result, transform) => ({\r\n                type: 'JsdocTypeOptional',\r\n                element: transform(result.element),\r\n                meta: {\r\n                    position: result.meta.position\r\n                }\r\n            }),\r\n            JsdocTypeObject: (result, transform) => ({\r\n                type: 'JsdocTypeObject',\r\n                meta: {\r\n                    separator: 'comma'\r\n                },\r\n                elements: result.elements.map(transform)\r\n            }),\r\n            JsdocTypeNumber: result => result,\r\n            JsdocTypeNull: result => result,\r\n            JsdocTypeNotNullable: (result, transform) => ({\r\n                type: 'JsdocTypeNotNullable',\r\n                element: transform(result.element),\r\n                meta: {\r\n                    position: result.meta.position\r\n                }\r\n            }),\r\n            JsdocTypeSpecialNamePath: result => result,\r\n            JsdocTypeObjectField: (result, transform) => ({\r\n                type: 'JsdocTypeObjectField',\r\n                key: result.key,\r\n                right: result.right === undefined ? undefined : transform(result.right),\r\n                optional: result.optional,\r\n                readonly: result.readonly,\r\n                meta: result.meta\r\n            }),\r\n            JsdocTypeJsdocObjectField: (result, transform) => ({\r\n                type: 'JsdocTypeJsdocObjectField',\r\n                left: transform(result.left),\r\n                right: transform(result.right)\r\n            }),\r\n            JsdocTypeKeyValue: (result, transform) => {\r\n                return {\r\n                    type: 'JsdocTypeKeyValue',\r\n                    key: result.key,\r\n                    right: result.right === undefined ? undefined : transform(result.right),\r\n                    optional: result.optional,\r\n                    variadic: result.variadic\r\n                };\r\n            },\r\n            JsdocTypeImport: (result, transform) => ({\r\n                type: 'JsdocTypeImport',\r\n                element: transform(result.element)\r\n            }),\r\n            JsdocTypeAny: result => result,\r\n            JsdocTypeStringValue: result => result,\r\n            JsdocTypeNamePath: result => result,\r\n            JsdocTypeVariadic: (result, transform) => {\r\n                const transformed = {\r\n                    type: 'JsdocTypeVariadic',\r\n                    meta: {\r\n                        position: result.meta.position,\r\n                        squareBrackets: result.meta.squareBrackets\r\n                    }\r\n                };\r\n                if (result.element !== undefined) {\r\n                    transformed.element = transform(result.element);\r\n                }\r\n                return transformed;\r\n            },\r\n            JsdocTypeTuple: (result, transform) => ({\r\n                type: 'JsdocTypeTuple',\r\n                elements: result.elements.map(transform)\r\n            }),\r\n            JsdocTypeName: result => result,\r\n            JsdocTypeFunction: (result, transform) => {\r\n                const transformed = {\r\n                    type: 'JsdocTypeFunction',\r\n                    arrow: result.arrow,\r\n                    parameters: result.parameters.map(transform),\r\n                    constructor: result.constructor,\r\n                    parenthesis: result.parenthesis\r\n                };\r\n                if (result.returnType !== undefined) {\r\n                    transformed.returnType = transform(result.returnType);\r\n                }\r\n                return transformed;\r\n            },\r\n            JsdocTypeKeyof: (result, transform) => ({\r\n                type: 'JsdocTypeKeyof',\r\n                element: transform(result.element)\r\n            }),\r\n            JsdocTypeParenthesis: (result, transform) => ({\r\n                type: 'JsdocTypeParenthesis',\r\n                element: transform(result.element)\r\n            }),\r\n            JsdocTypeProperty: result => result,\r\n            JsdocTypePredicate: (result, transform) => ({\r\n                type: 'JsdocTypePredicate',\r\n                left: transform(result.left),\r\n                right: transform(result.right)\r\n            }),\r\n            JsdocTypeIndexSignature: (result, transform) => ({\r\n                type: 'JsdocTypeIndexSignature',\r\n                key: result.key,\r\n                right: transform(result.right)\r\n            }),\r\n            JsdocTypeMappedType: (result, transform) => ({\r\n                type: 'JsdocTypeMappedType',\r\n                key: result.key,\r\n                right: transform(result.right)\r\n            }),\r\n            JsdocTypeAsserts: (result, transform) => ({\r\n                type: 'JsdocTypeAsserts',\r\n                left: transform(result.left),\r\n                right: transform(result.right)\r\n            })\r\n        };\r\n    }\r\n\r\n    const visitorKeys = {\r\n        JsdocTypeAny: [],\r\n        JsdocTypeFunction: ['parameters', 'returnType'],\r\n        JsdocTypeGeneric: ['left', 'elements'],\r\n        JsdocTypeImport: [],\r\n        JsdocTypeIndexSignature: ['right'],\r\n        JsdocTypeIntersection: ['elements'],\r\n        JsdocTypeKeyof: ['element'],\r\n        JsdocTypeKeyValue: ['right'],\r\n        JsdocTypeMappedType: ['right'],\r\n        JsdocTypeName: [],\r\n        JsdocTypeNamePath: ['left', 'right'],\r\n        JsdocTypeNotNullable: ['element'],\r\n        JsdocTypeNull: [],\r\n        JsdocTypeNullable: ['element'],\r\n        JsdocTypeNumber: [],\r\n        JsdocTypeObject: ['elements'],\r\n        JsdocTypeObjectField: ['right'],\r\n        JsdocTypeJsdocObjectField: ['left', 'right'],\r\n        JsdocTypeOptional: ['element'],\r\n        JsdocTypeParenthesis: ['element'],\r\n        JsdocTypeSpecialNamePath: [],\r\n        JsdocTypeStringValue: [],\r\n        JsdocTypeSymbol: ['element'],\r\n        JsdocTypeTuple: ['elements'],\r\n        JsdocTypeTypeof: ['element'],\r\n        JsdocTypeUndefined: [],\r\n        JsdocTypeUnion: ['elements'],\r\n        JsdocTypeUnknown: [],\r\n        JsdocTypeVariadic: ['element'],\r\n        JsdocTypeProperty: [],\r\n        JsdocTypePredicate: ['left', 'right'],\r\n        JsdocTypeAsserts: ['left', 'right']\r\n    };\r\n\r\n    function _traverse(node, parentNode, property, onEnter, onLeave) {\r\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\r\n        const keysToVisit = visitorKeys[node.type];\r\n        for (const key of keysToVisit) {\r\n            const value = node[key];\r\n            if (value !== undefined) {\r\n                if (Array.isArray(value)) {\r\n                    for (const element of value) {\r\n                        _traverse(element, node, key, onEnter, onLeave);\r\n                    }\r\n                }\r\n                else {\r\n                    _traverse(value, node, key, onEnter, onLeave);\r\n                }\r\n            }\r\n        }\r\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\r\n    }\r\n    /**\r\n     * A function to traverse an AST. It traverses it depth first.\r\n     * @param node the node to start traversing at.\r\n     * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\r\n     * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\r\n     */\r\n    function traverse(node, onEnter, onLeave) {\r\n        _traverse(node, undefined, undefined, onEnter, onLeave);\r\n    }\r\n\r\n    exports.catharsisTransform = catharsisTransform;\r\n    exports.identityTransformRules = identityTransformRules;\r\n    exports.jtpTransform = jtpTransform;\r\n    exports.parse = parse;\r\n    exports.stringify = stringify;\r\n    exports.stringifyRules = stringifyRules;\r\n    exports.transform = transform;\r\n    exports.traverse = traverse;\r\n    exports.tryParse = tryParse;\r\n    exports.visitorKeys = visitorKeys;\r\n\r\n}));\r\n"],
  "mappings": "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",
  "names": ["exports", "Precedence", "pathGrammar", "type", "objectFieldGrammar", "quote", "rules", "transform"]
}
